* Create Key
  
   #+begin_src bash :results verbatim
     openssl genrsa -out ca-key.pem 2048
   #+end_src

* Create CSR
  
   #+begin_src bash :results verbatim
     openssl req -new -key ca-key.pem -out csr.pem \
             -subj "/CN=registryman/O=system:nodes/CN=system:node:registryman.default.svc.cluster.local" \
             -addext "subjectAltName = DNS:registryman-webhook.default.svc" \
             -addext "extendedKeyUsage = clientAuth"
   #+end_src
   
* Request the signing
  
   #+begin_src bash :results verbatim
     cat <<EOF | kubectl apply -f -
     apiVersion: certificates.k8s.io/v1
     kind: CertificateSigningRequest
     metadata:
       name: registryman-webhook
     spec:
       request: $(base64 -w 0 csr.pem)
       signerName: kubernetes.io/kubelet-serving
       usages:
       - digital signature
       - key encipherment
       - server auth
     EOF
   #+end_src

* Sign the request
  
   #+begin_src bash :results verbatim
     kubectl certificate approve registryman-webhook
   #+end_src

* Fetch the certificate
  
   #+begin_src bash :results verbatim
     kubectl get csr/registryman-webhook -o "jsonpath={.status.certificate}" | base64 -d - > ca.pem
   #+end_src

* Get the Kubernetes API server CA

   #+begin_src bash :results verbatim
     kubectl config view --raw --minify -o "jsonpath={.clusters[0].cluster.certificate-authority-data}"
   #+end_src
   
* Deploy the resources
  
   #+begin_src bash :results verbatim
     kustomize build . | kubectl apply -f -
   #+end_src
